# -*- coding: utf-8 -*-
"""Djikstra Cheapest Ticket.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o0tCVv_Eg0PdkViHRG7pDFMiXF4ezcPU
"""

# !pip install networkx
import time
from collections import defaultdict
from random import randrange
#from amadeus import Client, ResponseError, Location
import json
import pandas as pd
from collections import defaultdict

class Graph():
    def __init__(self):
        self.edges=defaultdict(list)
        self.weights={}
    
    def addEdgetograph(self, from_node, to_node, weight):
        self.edges[from_node].append(to_node)
        self.edges[to_node].append(from_node)
        self.weights[(from_node, to_node)] = weight
        self.weights[(to_node, from_node)] = weight
 
graph = Graph()
 
edges = [
    ('JOG', 'JKT', 20),
    ('JOG', 'DPS', 68),
    ('JOG', 'SUB', 48),
 
    ('JKT', 'DPS', 32),
    ('JKT', 'KUL', 93),
    ('JKT', 'SIN', 24),
    ('JKT', 'MNL', 296),
    ('JKT', 'SEO', 360),
    ('JKT','SUB', 27),
 
    
 
    
    ('KUL','SEO', 416), 
    ('KUL','DPS', 124),
 
    ('MNL','SEO', 60),
    ('MNL','TOK', 310),
    ('MNL','KUL', 128),
    ('MNL','SEO', 60),
 
    ('TOK','SIN', 555),
    ('TOK','JKT', 390),
    ('TOK','SEO', 100),
    
    
    ('DPS','KUL', 124),
    ('DPS','SUB', 17),
 
    ('FRA','LON', 46),
 
    ('SEO','TOK', 65),
    ('SEO','MNL', 75),
 
    ('SIN', 'LON', 561),
    ('SIN', 'MNL', 148),
    ('SIN', 'THA', 74),
    ('SIN', 'SEO', 389),
    ('SIN','FRA', 461),
    ('SIN','LON', 565),
    ('SIN','KUL', 22),
 
    ('SUB', 'SIN', 39)
    
 
    
] #Edge's stored in lists
#SUB=Surabaya
for edge in edges:
    graph.addEdgetograph(*edge)

def djikstra(graph, start, end):
    shortestPaths={start: (None, 0)}#inserts shortest paths to a dictionary, initial nodeis set to nowhere or none and 0 weight. Storing results when pairing which each neighbors
    currNode=start
    visited=set()#Records all nodes that are passed by
    print('sp',shortestPaths)
    
    while currNode != end:
        visited.add(currNode)
        destinations=graph.edges[currNode] #Neighbors of current node
        print('dest is',destinations)
        weighttoCurrnode=shortestPaths[currNode][1] #Accessing key storing weight to current node that're stored in shortestPath dictionary ('node','weight')
        print('weight is',weighttoCurrnode)
        print(currNode)
        for nextNode in destinations: #Checking neighbor of current node
            
            weight=graph.weights[(currNode, nextNode)]+weighttoCurrnode
            if nextNode not in shortestPaths: #if the neighbor is not in shortest path dictionary, append it
                shortestPaths[nextNode]=(currNode,weight)
          
            else: #if it is in the shortest path dictionary already, check if the weight of the node is larger than the earlier append
                currentShortestwe=shortestPaths[nextNode][1]
                if currentShortestwe>weight:
                    shortestPaths[nextNode]=(currNode,weight)
                   
            print('shortest path: ',shortestPaths)
             
        nextDest={node: shortestPaths[node] for node in shortestPaths if node not in visited}
        
        print('next des',nextDest)
        print('visited',visited)
        if not nextDest:
            return "Route Not Possible"
        #next node is the destination with the lowest weight
        currNode=min(nextDest,key=lambda k:nextDest[k][1]) #Sort by minimum from the nextDest
        print('current node:',currNode)
    
    
    a=nextDest[end][1]

    #Work back through destinations in shortest path    
    path=[]
    while currNode is not None:
        path.append(currNode)
        nextNode=shortestPaths[currNode][0]
        currNode=nextNode
    
    path=path[::-1]#Path reversal
    return  {'path':path, 'TotalPrice US$:':a}

djikstra(graph,'JOG','KUL')

